// script generated by Sapien bioprocessor
// unit running NEUROS WYVEC

// BEHOLD MY GLORIOUS SPAGETTI
// ALL HAIL ARRAYS
// current version: v0.3.0 enviroment and hyper-jumping
// working on: modules and mining


/*
// load fonts
var tomorrow_light;
var tomorrow_medium;
function preload() {
  tomorrow_light = loadFont("/Tomorrow-Light.ttf");
  tomorrow_medium = loadFont("/Tomorrow-Medium.ttf");
}
*/

let themePrimary = [255, 255, 255];
let themeSecondary = [0, 90, 255];
let themeSecondaryDark = [0, 30, 150];
let themeTertiary = [245, 100, 20];
let themeTertiaryDark = [150, 30, 0];

let nThresh = 0.5; // noise threshold, setting this too high can cause the generation to fail
let Scount = 120; // star count
let seed = 302; // random generation seed
let Pstar = 1; // the current star
let Pstation = "null"; // the current station
let maxJump = 100; // the maximum jump distance
let fuel = 500; // used for jumping and possibly other operations
let maxFuel = 1000; // maximum fuel tank capacity
let credits = 500; // currency
let cargoSlots = 8;
let maxStack = 50; // how much of a single item type will typically stack
let cargo = []; // resources and items
let maxModules = 2;
let modules = []; // ship upgrades
let weight = 100; // weight of ship, with modules and cargo
let maxWeight = 200; // the maximum weight that the ship can jump with, less weight uses less fuel

let paused = false // whether the game is paused
let FPScounter = false
let DTlog = []; // used to calculate the average FPS

let screen = "NONE";
let m = []; // star map positions
let inf = []; // star names
let cl = []; // star classes
let sys = []; // solar systems and planets, sys[solar system][planet][data]
let classes = [
  // star types
  "Red M-Class",
  "Red M-Class", // repeated to make it twice as common
  "Yellow M-Class",
  "Blue M-Class",
  "Red Giant",
  "Neutron Star",
  "White Dwarf",
];
let stations = []; // array of space stations
let industries = [
  // space station types
  "Mining",
  "Refining",
  "Technology",
  "Organics",
  "Manufacturing",
];
// I was very close to just using arrays again
// all modules should have an onInstall, onRemove, update, and screen function
// a screen function is needed if the module needs an interface (Ex: the refinery needs an interface, cargo racks do not)
// if the module does not have a screen set screen to false
let moduleTypes = [

  cargoRackS = {
    name: "Cargo Rack S",
    soldAt: ["anywhere"],
    price: 150,
    description: "Increases storage capacity by 4 stacks.",
    onInstall: function(){
      cargoSlots += 4
      for(let i = 0; i < 4; i++){
        cargo[cargo.length] = ["EMPTY"]
      }
    },
    onRemove: function(){
      cargoSlots -= 4
      for(i = 0; i < 4; i++){
        // attempts to move cargo into lower areas to reduce loss of items
        let tempStack = cargo[cargoSlots + i]
        let cargoCount = getCargo(tempStack[0])
        cargo = removeCargo(tempStack[0],cargoCount)[0]
        cargo = addCargo(tempStack[0],cargoCount)[0]
      }
      cargo.length = cargoSlots
    },
    update: function(){

    },
    screen: false
  },
  RefineryS = {
    name: "Refinery S",
    price: 300,
    soldAt: ["Mining","Refining","Technology","Manufacturing"],
    description: "Refines raw goods (Ex: ores into metals, algae into food, etc.)",
    inputStack: [["EMPTY"],["EMPTY"]],
    outputStack: [["EMPTY"],["EMPTY"]],
    processing: null,
    progress: 0,
    onInstall: function() {

    },
    onRemove: function() {

    },
    update: function(){

    },
    screen: function(){

    }
  },
  AlgaeProductionUnitS = {
    name: "Algae Production Unit S",
    price: 250,
    soldAt: ["Organics","Technology","Manufacturing"],
    description:"Slowly grows algae using water.",
    water: 0,
    algae: 0,
    progress: 0,
    working: false,
    onInstall: function() {
      newTimer("Algae Timer")
    },
    onRemove: function() {
      removeTimer("Algae Timer")
    },
    update: function(){
      if(!this.working && this.water > 0) {
        this.working = true
        this.water -= 1
        resetTimer("Algae Timer")
      }
      if(this.working)this.progress = min(round(getTimer("Algae Timer")/20,3) * 100, 100)
      if(this.progress >= 100 && this.algae < 150 && this.working){
        this.algae += 3
        this.working = false
        this.progress = 0
      }
    },
    screen: function(){
      let SW = 700
      let SH = 500
      
      let xo = round((windowWidth/2)-(SW/2)) + 0.5
      let yo = round((windowHeight/2)-(SH/2)) + 0.5
      
      strokeWeight(1.5)
      stroke(themePrimary);
      fill(10,10,15)
      rect(xo,yo,SW,SH)
      
      if(!buttonsLoaded){
        

        newButton("Add 1 Water Button", "add 1",20, xo + 20, yo + 200, 70, 30, color(0,0,255), color(10,10,15), color(0,0,255), color(10,10,15), 2,
      function(){
        let availableWater = min(getCargo("Water"),50 - modules[+screen.split(" ")[1]].water,1)
        if(availableWater <= 0) return
        let removal = removeCargo("Water", availableWater)
        cargo = removal[0]
        modules[+screen.split(" ")[1]].water += availableWater
      }, CENTER, CENTER)
      setButtonEnabled("Add 1 Water Button", true)

      newButton("Add 10 Water Button", "add 10",20, xo + 100, yo + 200, 70, 30, color(0,0,255), color(10,10,15), color(0,0,255), color(10,10,15), 2,
      function(){
        let availableWater = min(getCargo("Water"),50 - modules[+screen.split(" ")[1]].water,10)
        if(availableWater <= 0) return
        let removal = removeCargo("Water", availableWater)
        cargo = removal[0]
        modules[+screen.split(" ")[1]].water += availableWater
      }, CENTER, CENTER)
      setButtonEnabled("Add 10 Water Button", true)

      newButton("Add Max Water Button", "add max",20, xo + 180, yo + 200, 90, 30, color(0,0,255), color(10,10,15), color(0,0,255), color(10,10,15), 2,
      function(){
        let availableWater = min(getCargo("Water"),50 - modules[+screen.split(" ")[1]].water,50)
        if(availableWater <= 0) return
        let removal = removeCargo("Water", availableWater)
        cargo = removal[0]
        modules[+screen.split(" ")[1]].water += availableWater
      }, CENTER, CENTER)
      setButtonEnabled("Add Max Water Button", true)



      newButton("Take 1 Algae Button", "take 1",20, xo + 20, yo + 330, 70, 30, color(0,255,0), color(10,10,15), color(0,255,0), color(10,10,15), 2,
      function(){
        let availableAlgae = min(addCargo("Algae",10000)[2],modules[+screen.split(" ")[1]].algae,1)
        if(availableAlgae <= 0) return
        let addition = addCargo("Algae", availableAlgae)
        cargo = addition[0]
        modules[+screen.split(" ")[1]].algae -= availableAlgae
      }, CENTER, CENTER)
      setButtonEnabled("Take 1 Algae Button", true)

      newButton("Take 10 Algae Button", "take 10",20, xo + 100, yo + 330, 80, 30, color(0,255,0), color(10,10,15), color(0,255,0), color(10,10,15), 2,
      function(){
        let availableAlgae = min(addCargo("Algae",10000)[2],modules[+screen.split(" ")[1]].algae,10)
        if(availableAlgae <= 0) return
        let addition = addCargo("Algae", availableAlgae)
        cargo = addition[0]
        modules[+screen.split(" ")[1]].algae -= availableAlgae
      }, CENTER, CENTER)
      setButtonEnabled("Take 10 Algae Button", true)

      newButton("Take Max Algae Button", "take max",20, xo + 190, yo + 330, 100, 30, color(0,255,0), color(10,10,15), color(0,255,0), color(10,10,15), 2,
      function(){
        let availableAlgae = min(addCargo("Algae",10000)[2],modules[+screen.split(" ")[1]].algae,150)
        if(availableAlgae <= 0) return
        let addition = addCargo("Algae", availableAlgae)
        cargo = addition[0]
        modules[+screen.split(" ")[1]].algae -= availableAlgae
      }, CENTER, CENTER)
      setButtonEnabled("Take Max Algae Button", true)

        buttonsLoaded = true
      }

      textSize(30)
      fill(0,210,0)
      noStroke()
      textAlign(LEFT,TOP)
      text("Biosis Modular Algae Farm mk 2.2346.1", xo + 20, yo + 20)

      fill(themePrimary)
      textSize(18)
      text("water: " + this.water, xo + 20, yo + 140)
      text("on ship: "+getCargo("Water"), xo + 20, yo + 180)
      text("algae: " + this.algae, xo + 20, yo + 270)
      text("room on ship: " + addCargo("Algae", 10000)[2], xo + 20, yo + 310)

      strokeWeight(1)
      stroke(0,0,255)
      noFill()
      rect(xo + 20, yo + 162, 200, 5)
      fill(0,0,255)
      rect(xo + 20, yo + 162, 200 * (this.water / 50), 5)

      stroke(0,255,0)
      noFill()
      rect(xo + 20, yo + 292, 200, 5)
      fill(0,255,0)
      rect(xo + 20, yo + 292, 200 * (this.algae / 150), 5)


      // big algae panel thing to fill in space

      fill(0,(this.progress/100 * 200), (255 - (this.progress/100 * 230)) * min(this.water, 1) + 15)
      strokeWeight(3)
      stroke(0,(this.progress/100 * 200) - 60, 230 - (this.progress/100 * 230) - 60)
      rect(xo + 400, yo + 140, 40, 260)
      rect(xo + 454, yo + 140, 40, 260)
      rect(xo + 508, yo + 140, 40, 260)
      rect(xo + 562, yo + 140, 40, 260)
      rect(xo + 616, yo + 140, 40, 260)

      fill(10,10,15)
      stroke(120)
      strokeWeight(2)
      rect(xo + 380 - 0.5, yo + 100 - 0.5, 300,41)
      rect(xo + 380 - 0.5, yo + 400 - 0.5, 300,40)

      strokeWeight(1)
      rect(xo + 385, yo + 105, 60, 30)
      noFill()
      rect(xo + 660, yo + 430, 20, 10)
      rect(xo + 390, yo + 430, 5, 5)
      rect(xo + 400, yo + 430, 5, 5)
      rect(xo + 410, yo + 430, 5, 5)

      noStroke()
      fill(this.working?130:230,0,0)
      rect(xo + 650 - 0.5, yo + 105 - 0.5, 10, 5)
      fill(0,this.working?240:130,0)
      rect(xo + 665 - 0.5, yo + 105 - 0.5, 10, 5)

    }
  }

]

function installShipModule(moduleName){
  if(modules.length < maxModules){
    let moduleFound = false
    for(let i = 1; i < moduleTypes.length; i++){
      if(moduleTypes[i].name == moduleName){
        modules[modules.length] = Object.assign({},moduleTypes[i])
        moduleFound = true
      }
    }
    if(!moduleFound) return
    modules[modules.length - 1].onInstall()
  }
}

let commod = [
  // list of possible commodities, their typical prices, and where they are sold and bought, and it's weight per unit  commod[commodity][0 = name, 1 = typical price, 2 = [places it can be sold], 3 = [places it can be bought], 4 = weight, 5 = color]
  ["Hyper Fuel", 0.5, ["anywhere"], ["anywhere"], 0.5, [215, 50, 235]],
  ["Iron Ore", 2, ["Refining"], ["Mining"], 3, [100, 30, 5]],
  ["Copper Ore", 2, ["Refining"], ["Mining"], 3, [150, 100, 0]],
  ["Uranium Ore", 7, ["Refining"], ["Mining"], 4, [0, 240, 100]],
  ["Carbon Ore", 2, ["Refining"], ["Mining"], 2, [50, 50, 50]],
  ["Gold Ore", 4, ["Refining"], ["Mining"], 4, [200, 180, 0]],
  ["Ice", 1, ["Mining", "Refining"], ["Mining"], 3, [0, 40, 220]],
  [
    "Iron",
    5,
    ["Mining", "Refining", "Technology", "Manufacturing"],
    ["Refining"],
    5,
    [120, 130, 120],
  ],
  [
    "Copper",
    5,
    ["Mining", "Refining", "Technology", "Manufacturing"],
    ["Refining"],
    5,
    [230, 110, 0],
  ],
  [
    "Unenriched Uranium",
    10,
    ["Mining", "Refining", "Technology", "Manufacturing"],
    ["Refining"],
    5,
    [0, 240, 100],
  ],
  [
    "Enriched Uranium",
    25,
    ["Mining", "Refining", "Technology"],
    ["Refining", "Technology"],
    5,
    [0, 240, 100],
  ],
  [
    "Carbon",
    6,
    ["Mining", "Refining", "Technology", "Organics", "Manufacturing"],
    ["Refining"],
    3,
    [50, 50, 50],
  ],
  [
    "Gold",
    18,
    ["Mining", "Refining", "Technology", "Manufacturing"],
    ["Refining"],
    7,
    [200, 180, 0],
  ],
  ["Water", 3, ["anywhere"], ["anywhere"], 3, [0, 40, 220]],
  ["Hydrogen", 1, ["Refining"], ["Technology","Manufacturing"], 0.5, [235,235,255]],
  ["Oxygen", 1, ["Refining"], ["Technology","Manufacturing"], 0.5, [235,255,255]],
  ["Hull Plating", 10, ["anywhere"], ["Manufacturing"], 8, [140, 140, 145]],
  ["Motors", 12, ["Technology"], ["Manufacturing"], 3, [150, 130, 120]],
  ["Algae", 1, ["Technology"], ["Organics"], 1, [0, 130, 100]],
  ["FOODSNACK™", 5, ["anywhere"], ["Organics"], 1, [0, 150, 100]],
  ["Processors", 20, ["anywhere"], ["Technology"], 2, [230, 230, 230]],
  ["Solar Panels", 25, ["anywhere"], ["Technology"], 10, [10, 230, 230]],
];

var smeltables = [
  [2, "Iron Ore", 1, "Iron"],
  [2, "Copper Ore", 1, "Copper"],
  [2, "Carbon Ore", 1, "Carbon"],
  [3, "Gold Ore", 1, "Gold"],
  [2, "Ice", 1, "Water"],
  [2,"Algae",1,"FOODSNACK™"]
];
function deepCopy(array) {
  return JSON.parse(JSON.stringify(array));
}

function getCommodity(name) {
  for (let i = 0; i < commod.length; i++) {
    if (commod[i][0] == name) {
      return deepCopy(commod[i]);
    }
  }
}

// joint system
let joints = []; // [0 = name, 1 = rotation, 2 = X, 3 = Y]

function jointOffset(name, X, Y) {
  let joint;
  for (let i = 0; i < joints.length; i++) {
    if (joints[i][0] == name) {
      joint = joints[i];
    }
  }
  if (joint == null) return;

  let Jr = joint[1];
  let Jx = joint[2];
  let Jy = joint[3];

  let x = cos(Jr) * Y + cos(Jr + 180 / 2) * X + Jx;
  let y = sin(Jr) * Y + sin(Jr + 180 / 2) * X + Jy;
  return [x, y];
}

function createJoint(name, R, X, Y) {
  joints[joints.length] = [name, R, X, Y];
}

function setJoint(name, R, X, Y) {
  for (let i = 0; i < joints.length; i++) {
    if (joints[i][0] == name) {
      joints[i] = [name, R, X, Y];
    }
  }
}

function linkJoint(name, linkName, R, L) {
  let joint;
  for (let i = 0; i < joints.length; i++) {
    if (joints[i][0] == name) {
      joint = i;
    }
  }
  if (joint == null) {
    print("no joint");
    return;
  }

  let link;
  for (let i = 0; i < joints.length; i++) {
    if (joints[i][0] == linkName) {
      link = i;
    }
  }
  if (link == null) {
    print("no link");
    return;
  }

  let r = joints[link][1] + R;
  let x = cos(r) * L + joints[link][2];
  let y = sin(r) * L + joints[link][3];

  joints[joint] = [name, r, x, y];

  if (debug) {
    line(joints[link][2], joints[link][3], joints[joint][2], joints[joint][3]);
  }
}

function pointsLine(POINT1, POINT2) {
  line(POINT1[0], POINT1[1], POINT2[0], POINT2[1]);
}

function pointsTriangle(POINT1, POINT2, POINT3) {
  triangle(POINT1[0], POINT1[1], POINT2[0], POINT2[1], POINT3[0], POINT3[1]);
}

// might be a bit weird due to the order of the diagonals not being specified
function pointsRectangle(POINT1,POINT2,POINT3,POINT4){
  pointsLine(POINT1,POINT2)
  pointsLine(POINT2,POINT3)
  pointsLine(POINT3,POINT4)
  pointsLine(POINT4,POINT1)
  noStroke()
  pointsTriangle(POINT1,POINT2,POINT3)
  pointsTriangle(POINT1,POINT4,POINT3)
  stroke(STROKE)
}

function triangleArea(x1,y1,x2,y2,x3,y3){
  x1 = round(x1,3)
  y1 = round(y1,3)
  x2 = round(x2,3)
  y2 = round(y2,3)
  x3 = round(x3,3)
  y3 = round(y3,3)
  return (1/2)*abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))
}

function checkTrianglePoint(x1,y1,x2,y2,x3,y3,px,py){
  let area = triangleArea(x1,y1,x2,y2,x3,y3)
  
  px = round(px,3)
  py = round(py,3)
  
  if(area + 0.01 >= triangleArea(px,py,x2,y2,x3,y3)+triangleArea(x1,y1,px,py,x3,y3)+triangleArea(x1,y1,x2,y2,px,py)){
    return true
  } else {
    return false
  }
}

var cameraPos = [0,0]

var canDock = false;
var docked = false;
var shipJoint;


var playerShip;
var asteroid;
var station;
var dockingPort;

var speed = 0.5;
var turn = 0.0005;

function createStation(lightCol){
  station = new Sprite(random(150, 300),random(-200,200),100,100)
  station.diameter = 150
  station.collider = "static"
  station.color = color(10,10,15,255)
  station.stroke = color(200)
  station.spinSpeed = 10 // custom value, determines the visual rotation speed of the station and the orbit speed of docking ports
  station.lightColor = lightCol
  station.allowSleeping = false;
  
  dockingPort1 = new Sprite(station.x + station.diameter/2,station.y,20,20)
  dockingPort1.collider = "kinematic"
  dockingPort1.color = color(10,10,15)
  dockingPort1.stroke = color(200)
  dockingPort1.station = "station"
  dockingPort1.strokeWeight = 0.2
  
  dockingPort2 = new Sprite(station.x - station.diameter/2,station.y,20,20)
  dockingPort2.collider = "kinematic"
  dockingPort2.color = color(10,10,15)
  dockingPort2.stroke = color(200)
  dockingPort2.station = "station"
  dockingPort2.strokeWeight = 0.2
  
  dockingPort3 = new Sprite(station.x,station.y - station.diameter/2,20,20)
  dockingPort3.collider = "kinematic"
  dockingPort3.color = color(10,10,15)
  dockingPort3.stroke = color(200)
  dockingPort3.station = "station"
  dockingPort3.strokeWeight = 0.2
  
  dockingPort4 = new Sprite(station.x,station.y + station.diameter/2,20,20)
  dockingPort4.collider = "kinematic"
  dockingPort4.color = color(10,10,15)
  dockingPort4.stroke = color(200)
  dockingPort4.station = "station"
  dockingPort4.strokeWeight = 0.2
}


createJoint("dockingPort1",0,0,0)
createJoint("dockingPort2",0,0,0)
createJoint("dockingPort3",0,0,0)
createJoint("dockingPort4",0,0,0)
createJoint("station",0,0,0)
function updateStation(){
  let x = dockingPort1.x - station.x
  let y = dockingPort1.y - station.y
  
  let angle = atan(y/x)
  if(x > 0) angle = angle + 180
  angle += 90
  
  dockingPort1.direction = angle
  dockingPort1.speed = (station.spinSpeed/360) * PI * (station.diameter/60)
  dockingPort1.rotation = angle
  setJoint("dockingPort1",angle,dockingPort1.x,dockingPort1.y)
  // prevents the docking port from drifting off into space due to imprecision
  if(dist(station.x,station.y,dockingPort1.x,dockingPort1.y) > (station.diameter/2) + 0.5){
    dockingPort1.x = station.x + cos(angle+90)*(station.diameter/2);
    dockingPort1.y = station.y + sin(angle+90)*(station.diameter/2);
  }
  
  let p1 = jointOffset("dockingPort1",10,10)
  let p2 = jointOffset("dockingPort1",10,-10)
  let p3 = jointOffset("dockingPort1",30,10)
  let p4 = jointOffset("dockingPort1",30,-10)
  
  if(checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p2[0],p2[1],playerShip.x,playerShip.y) ||
    checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p3[0],p3[1],playerShip.x,playerShip.y) ) {
    canDock = true;
    if(kb.pressed("e") && !docked){
      docked = true;
      shipJoint = new GlueJoint(playerShip, dockingPort2)
      shipJoint.visible = false;
      buttonsLoaded = false
      screen = "STATION"
      consoleMessage("successfully docked with " + stations[Pstar][Pstation][3] + " station", 5)
    } else if((kb.pressed("e") || kb.pressed("escape")) && docked) {
      shipJoint.remove()
      screen = "NONE"
      buttonsLoaded = false;
      clearButtons()
      consoleMessage("undock successful", 5)
      docked = false;
      TS = 0;
    }
  }
  
  
  angle += 90
  
  dockingPort3.direction = angle
  dockingPort3.speed = (station.spinSpeed/360) * PI * (station.diameter/60)
  dockingPort3.rotation = angle
  setJoint("dockingPort3",angle,dockingPort3.x,dockingPort3.y)
  // prevents the docking port from drifting off into space due to imprecision
  if(dist(station.x,station.y,dockingPort3.x,dockingPort3.y) > (station.diameter/2) + 0.5){
    dockingPort3.x = station.x + cos(angle+90)*(station.diameter/2);
    dockingPort3.y = station.y + sin(angle+90)*(station.diameter/2);
  }
  
  p1 = jointOffset("dockingPort3",10,10)
  p2 = jointOffset("dockingPort3",10,-10)
  p3 = jointOffset("dockingPort3",30,10)
  p4 = jointOffset("dockingPort3",30,-10)
  
  if(checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p2[0],p2[1],playerShip.x,playerShip.y) ||
    checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p3[0],p3[1],playerShip.x,playerShip.y) ) {
    canDock = true;
    if(kb.pressed("e") && !docked){
      docked = true;
      shipJoint = new GlueJoint(playerShip, dockingPort2)
      shipJoint.visible = false;
      buttonsLoaded = false
      consoleMessage("successfully docked with " + stations[Pstar][Pstation][3] + " station", 5)
      screen = "STATION"
    } else if((kb.pressed("e") || kb.pressed("escape")) && docked) {
      shipJoint.remove()
      screen = "NONE"
      buttonsLoaded = false;
      clearButtons()
      consoleMessage("undock successful", 5)
      docked = false;
      TS = 0;
    }
  }
  
  angle += 90
  
  dockingPort2.direction = angle
  dockingPort2.speed = (station.spinSpeed/360) * PI * (station.diameter/60)
  dockingPort2.rotation = angle
  setJoint("dockingPort2",angle,dockingPort2.x,dockingPort2.y)
  // prevents the docking port from drifting off into space due to imprecision
  if(dist(station.x,station.y,dockingPort2.x,dockingPort2.y) > (station.diameter/2) + 0.5){
    dockingPort2.x = station.x + cos(angle+90)*(station.diameter/2);
    dockingPort2.y = station.y + sin(angle+90)*(station.diameter/2);
  }
  
  p1 = jointOffset("dockingPort2",10,10)
  p2 = jointOffset("dockingPort2",10,-10)
  p3 = jointOffset("dockingPort2",30,10)
  p4 = jointOffset("dockingPort2",30,-10)
  
  if(checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p2[0],p2[1],playerShip.x,playerShip.y) ||
    checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p3[0],p3[1],playerShip.x,playerShip.y) ) {
    canDock = true;
    if(kb.pressed("e") && !docked){
      docked = true;
      shipJoint = new GlueJoint(playerShip, dockingPort2)
      shipJoint.visible = false;
      buttonsLoaded = false
      consoleMessage("successfully docked with " + stations[Pstar][Pstation][3] + " station", 5)
      screen = "STATION"
    } else if((kb.pressed("e") || kb.pressed("escape")) && docked) {
      shipJoint.remove()
      screen = "NONE"
      buttonsLoaded = false;
      clearButtons()
      consoleMessage("undock successful", 5)
      docked = false;
      TS = 0;
    }
  }
  
  angle += 90
  
  dockingPort4.direction = angle
  dockingPort4.speed = (station.spinSpeed/360) * PI * (station.diameter/60)
  dockingPort4.rotation = angle
  setJoint("dockingPort4",angle,dockingPort4.x,dockingPort4.y)
  // prevents the docking port from drifting off into space due to imprecision
  if(dist(station.x,station.y,dockingPort4.x,dockingPort4.y) > (station.diameter/2) + 0.5){
    dockingPort4.x = station.x + cos(angle+90)*(station.diameter/2);
    dockingPort4.y = station.y + sin(angle+90)*(station.diameter/2);
  }
  
  p1 = jointOffset("dockingPort4",10,10)
  p2 = jointOffset("dockingPort4",10,-10)
  p3 = jointOffset("dockingPort4",30,10)
  p4 = jointOffset("dockingPort4",30,-10)
  
  if(checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p2[0],p2[1],playerShip.x,playerShip.y) ||
    checkTrianglePoint(p1[0],p1[1],p4[0],p4[1],p3[0],p3[1],playerShip.x,playerShip.y) ) {
    canDock = true;
    if(kb.pressed("e") && !docked){
      docked = true;
      shipJoint = new GlueJoint(playerShip, dockingPort2)
      shipJoint.visible = false;
      buttonsLoaded = false
      consoleMessage("successfully docked with " + stations[Pstar][Pstation][3] + " station", 5)
      screen = "STATION"
    } else if((kb.pressed("e") || kb.pressed("escape")) && docked) {
      shipJoint.remove()
      screen = "NONE"
      buttonsLoaded = false;
      clearButtons()
      consoleMessage("undock successful", 5)
      docked = false;
      TS = 0;
    }
  }
  
  
  setJoint("station",angle,0,0)
  
  // custom draw code for the station
  station.draw = () => {
    
    noFill()
    stroke(station.stroke)
    strokeWeight(0.4)
    pointsRectangle(
      jointOffset("station",-station.diameter/20,0),
      jointOffset("station",station.diameter/20,0),
      jointOffset("station",station.diameter/20,(station.diameter/2)-(station.diameter/20)),
      jointOffset("station",-station.diameter/20,(station.diameter/2)-(station.diameter/20))
    )
    pointsRectangle(
      jointOffset("station",-station.diameter/20,0),
      jointOffset("station",station.diameter/20,0),
      jointOffset("station",station.diameter/20,-(station.diameter/2)+(station.diameter/20)),
      jointOffset("station",-station.diameter/20,-(station.diameter/2)+(station.diameter/20))
    )
    pointsRectangle(
      jointOffset("station",0,-station.diameter/20),
      jointOffset("station",0,station.diameter/20),
      jointOffset("station",(station.diameter/2)-(station.diameter/20),station.diameter/20),
      jointOffset("station",(station.diameter/2)-(station.diameter/20),-station.diameter/20)
    )
    pointsRectangle(
      jointOffset("station",0,-station.diameter/20),
      jointOffset("station",0,station.diameter/20),
      jointOffset("station",-(station.diameter/2)+(station.diameter/20),station.diameter/20),
      jointOffset("station",-(station.diameter/2)+(station.diameter/20),-station.diameter/20)
    )
    strokeWeight(1)
    
    noFill()
    stroke(station.color)
    strokeWeight(station.diameter/6)
    circle(0,0,station.diameter-(station.diameter/6))
    fill(station.color)
    noStroke()
    circle(0,0,station.diameter/3)
    
    stroke(station.stroke)
    strokeWeight(0.2)
    noFill()
    stroke(station.stroke)
    circle(0,0,station.diameter-(station.diameter/3))
    noFill()
    stroke(station.stroke)
    circle(0,0,station.diameter)
    circle(0,0,station.diameter/3)
    
    fill(station.color)
    noStroke()
    pointsRectangle(
      jointOffset("station",-station.diameter/20,0),
      jointOffset("station",station.diameter/20,0),
      jointOffset("station",station.diameter/20,(station.diameter/2)-(station.diameter/20)),
      jointOffset("station",-station.diameter/20,(station.diameter/2)-(station.diameter/20))
    )
    noStroke()
    pointsRectangle(
      jointOffset("station",-station.diameter/20,0),
      jointOffset("station",station.diameter/20,0),
      jointOffset("station",station.diameter/20,-(station.diameter/2)+(station.diameter/20)),
      jointOffset("station",-station.diameter/20,-(station.diameter/2)+(station.diameter/20))
    )
    noStroke()
    pointsRectangle(
      jointOffset("station",0,-station.diameter/20),
      jointOffset("station",0,station.diameter/20),
      jointOffset("station",(station.diameter/2)-(station.diameter/20),station.diameter/20),
      jointOffset("station",(station.diameter/2)-(station.diameter/20),-station.diameter/20)
    )
    noStroke()
    pointsRectangle(
      jointOffset("station",0,-station.diameter/20),
      jointOffset("station",0,station.diameter/20),
      jointOffset("station",-(station.diameter/2)+(station.diameter/20),station.diameter/20),
      jointOffset("station",-(station.diameter/2)+(station.diameter/20),-station.diameter/20)
    )
    
    let angle;
    for (let i = 0; i < joints.length; i++) {
      if (joints[i][0] == "station") {
        angle = joints[i][1];
      }
    }
    
    let arcGapIn = 50
    let arcGapOut = 35
    
    let arcRadIn = station.diameter/4
    let arcRadOut = station.diameter-(station.diameter/20)
    
    stroke(station.lightColor)
    noFill()
    
    strokeWeight(2)
    strokeCap(PROJECT)
    arc(0,0,arcRadIn,arcRadIn, angle + 0 + (arcGapIn/2), angle + 0 + 90 - (arcGapIn/2))
    arc(0,0,arcRadIn,arcRadIn, angle + 90 + (arcGapIn/2), angle + 90 + 90 - (arcGapIn/2))
    arc(0,0,arcRadIn,arcRadIn, angle + 180 + (arcGapIn/2), angle + 180 + 90 - (arcGapIn/2))
    arc(0,0,arcRadIn,arcRadIn, angle + 270 + (arcGapIn/2), angle + 270 + 90 - (arcGapIn/2))
    
    strokeWeight(2.5)
    arc(0,0,arcRadOut,arcRadOut, angle + 0 + (arcGapOut/2), angle + 0 + 90 - (arcGapOut/2))
    arc(0,0,arcRadOut,arcRadOut, angle + 90 + (arcGapOut/2), angle + 90 + 90 - (arcGapOut/2))
    arc(0,0,arcRadOut,arcRadOut, angle + 180 + (arcGapOut/2), angle + 180 + 90 - (arcGapOut/2))
    arc(0,0,arcRadOut,arcRadOut, angle + 270 + (arcGapOut/2), angle + 270 + 90 - (arcGapOut/2))
    
  }
}


let rand;
let su = false;
let Fcount = 0;
let JbuttonEnabled = false;
let JbuttonHover = false;
let SbuttonEnabled = true;
let buttons = []; // first value in each table is the enabled value, 2nd is the button's name (NAMES SHOULD BE DIFFERENT)

let buttonsLoaded = false;

// button functions
function newButton(
  name,
  displayText,
  textsize,
  X,
  Y,
  W,
  H,
  Col1,
  Col2,
  ColP1,
  ColP2,
  bWidth,
  func,
  alx,
  aly,
  pad
) {
  // Col inputs should be arrays or color()s
  buttons[buttons.length] = [];
  buttons[buttons.length - 1][0] = false;
  buttons[buttons.length - 1][1] = name;
  buttons[buttons.length - 1][2] = displayText ?? "";
  buttons[buttons.length - 1][3] = textsize ?? 10;
  buttons[buttons.length - 1][4] = X ?? 50;
  buttons[buttons.length - 1][5] = Y ?? 50;
  buttons[buttons.length - 1][6] = W ?? 50;
  buttons[buttons.length - 1][7] = H ?? 50;
  buttons[buttons.length - 1][8] = Col1 ?? color(255);
  buttons[buttons.length - 1][9] = Col2 ?? color(0);
  buttons[buttons.length - 1][10] = ColP1 ?? color(255);
  buttons[buttons.length - 1][11] = ColP2 ?? color(0);
  buttons[buttons.length - 1][12] = bWidth ?? 1;
  buttons[buttons.length - 1][13] = func ?? function () {};
  buttons[buttons.length - 1][14] = alx ?? CENTER;
  buttons[buttons.length - 1][15] = aly ?? CENTER;
  buttons[buttons.length - 1][16] = pad ?? 0;
  buttons[buttons.length - 1][17] = false
}

// draws the button immediately rather than waiting to draw it last
function drawButton(buttonName){
  for(let i = 0; i < buttons.length; i++)
    if (buttons[i][0] && buttons[i][17] == false && buttons[i][1] == buttonName) {
      let Hover =
        mouseX > buttons[i][4] &&
        mouseX < buttons[i][4] + buttons[i][6] &&
        mouseY > buttons[i][5] &&
        mouseY < buttons[i][5] + buttons[i][7];
      strokeWeight(buttons[i][12]);
      textAlign(buttons[i][14], buttons[i][15]);
      if (!Hover) {
        stroke(buttons[i][8]);
        fill(buttons[i][9]);
        rect(
          buttons[i][4] + 0.5,
          buttons[i][5] + 0.5,
          buttons[i][6],
          buttons[i][7]
        );
        noStroke();
        fill(buttons[i][8]);
        textSize(buttons[i][3]);
        text(
          buttons[i][2],
          buttons[i][4] + 0.5 + buttons[i][16],
          buttons[i][5] + 0.5 + buttons[i][16],
          buttons[i][6] - buttons[i][16] * 2,
          buttons[i][7] - buttons[i][16] * 2
        );
      } else if (Hover) {
        stroke(buttons[i][10]);
        fill(buttons[i][10]);
        rect(
          buttons[i][4] + 0.5,
          buttons[i][5] + 0.5,
          buttons[i][6],
          buttons[i][7]
        );
        noStroke();
        fill(buttons[i][11]);
        textSize(buttons[i][3]);
        text(
          buttons[i][2],
          buttons[i][4] + 0.5 + buttons[i][16],
          buttons[i][5] + 0.5 + buttons[i][16],
          buttons[i][6] - buttons[i][16] * 2,
          buttons[i][7] - buttons[i][16] * 2
        );
        cursor(HAND);
      }
      buttons[i][17] = true
    }
  

}

function removeButton(name) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      for (let a = i; a < buttons.length; a++) {
        buttons[a] = buttons[a + 1];
      }
      buttons.length = buttons.length - 1;
      break;
    }
  }
}

function setButtonAlign(name, alx, aly) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][14] = aly;
      buttons[i][15] = alx;
    }
  }
}

function toggleButton(name) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][0] = !buttons[i][0];
    }
  }
}

function setButtonEnabled(name, value) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][0] = value;
    }
  }
}

function setButtonPos(name, X, Y) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][4] = X;
      buttons[i][5] = Y;
    }
  }
}

function setButtonSize(name, W, H) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][6] = W;
      buttons[i][7] = H;
    }
  }
}

function setButtonColors(name, Col1, Col2, ColP1, ColP2) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][8] = Col1;
      buttons[i][9] = Col2;
      buttons[i][10] = ColP1;
      buttons[i][11] = ColP2;
    }
  }
}

function setButtonText(name, Text, Size) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][2] = Text;
      buttons[i][3] = Size ?? buttons[i][3];
    }
  }
}

function setButtonBorder(name, b) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][12] = b;
    }
  }
}

function setButtonPadding(name, p) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][16] = p;
    }
  }
}

function setButtonFunction(name, func) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][13] = func;
    }
  }
}

function runButton(name) {
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][1] == name) {
      buttons[i][13]();
    }
  }
}

function clearButtons() {
  buttons = [];
}


// SETUP
// INITIAL SETUP AND UNIVERSE GENERATION
function setup() {
  createCanvas(windowWidth, windowHeight);
  randomSeed(seed);
  noiseSeed(seed);
  
  camera.zoom = 5
  
  // code in  scripts/worldGeneration.js
  generateWorld()
  
  playerShip = new Sprite(0,0,8,6);
  playerShip.mass = 0.7
  playerShip.rotationDrag = 5
  playerShip.drag = 5
  playerShip.color = color(10,10,15)
  playerShip.stroke = color(0,0,255)
  playerShip.strokeWeight = 0.3
  playerShip.maxIntegrity = 100;
  playerShip.integrity = 100;
  
  function resetPlayer(){
    playerShip.x = 0
    playerShip.y = 0
    playerShip.rotationSpeed = 0
    playerShip.speed = 0
    camera.x = playerShip.x
    camera.y = playerShip.y
  }
  
  camera.x = playerShip.x
  camera.y = playerShip.y

  
  
  // initialize cargo
  for (let i = 0; i < cargoSlots; i++) {
    cargo[i] = ["EMPTY"];
  }

  installShipModule("Algae Production Unit S")
}

// give the star system index and the station index and the commodity name and return the station's commodity data
// I'm sick of having to keep writing the code to find station data some I'm finally putting it in a function like a somewhat sane person
function findCommodity(starSystem, station, commodity) {
  for (let i = 0; i < stations[starSystem][station][4].length; i++) {
    if (stations[starSystem][station][4][i][0] == commodity)
      return stations[starSystem][station][4][i];
  }
  return false
}

// cargo functions

// returns a table of [0 = resulting cargo, 1 = success, 2 = items added]
function addCargo(commodityName, count, CARGO) {
  
  CARGO = CARGO??cargo // sets the input cargo array to the ship's if none is given

  let spaceAvailable = false;
  let availableRoom = 0;
  let item;
  for (let i = 0; i < commod.length; i++) {
    if (commod[i][0] == commodityName) {
      item = commod[i];
    }
  }

  // error handling
  if (commodityName == "EMPTY") {
    print('DONT TRY TO ADD "EMPTY" YOU IDIOT!');
    return [CARGO, false, 0];
  }
  if (item == null) {
    print("no matching item!");
    return [CARGO, false, 0];
  }
  if (count < 0) {
    print("USE removeCargo TO REMOVE CARGO, NOT addCargo!");
    return [CARGO, false, 0];
  }

  // check whether there is room available and how much more of the item it can hold
  for (let i = 0; i < CARGO.length; i++) {
    if (CARGO[i][0] == "EMPTY") {
      spaceAvailable = true;
      availableRoom += floor(maxStack / item[4]);
    }

    if (CARGO[i][0] == item[0] && CARGO[i][1] <= floor(maxStack / item[4])) {
      spaceAvailable = true;
      availableRoom += floor(maxStack / item[4]) - CARGO[i][1];
    }
  }

  // return the original cargo and failed if there is no room
  if (!spaceAvailable) return [CARGO, false, 0];

  let newCargo = JSON.parse(JSON.stringify(CARGO));
  let cargoToAdd;
  if (availableRoom >= count) {
    cargoToAdd = count;
  } else {
    cargoToAdd = availableRoom;
  }
  let addedCargo = cargoToAdd;

  for (let i = 0; i < newCargo.length; i++) {
    if (newCargo[i][0] == "EMPTY") {
      if (cargoToAdd >= floor(maxStack / item[4])) {
        newCargo[i][0] = item[0];
        newCargo[i][1] = floor(maxStack / item[4]);
        cargoToAdd -= floor(maxStack / item[4]);
      } else if (cargoToAdd > 0) {
        newCargo[i][0] = item[0];
        newCargo[i][1] = cargoToAdd;
        cargoToAdd = 0;
      }
    }

    if (newCargo[i][0] == item[0]) {
      if (cargoToAdd >= floor(maxStack / item[4]) - newCargo[i][1]) {
        newCargo[i][0] = item[0];
        cargoToAdd -= floor(maxStack / item[4]) - newCargo[i][1];
        newCargo[i][1] = floor(maxStack / item[4]);
      } else if (cargoToAdd > 0) {
        newCargo[i][0] = item[0];
        newCargo[i][1] += cargoToAdd;
        cargoToAdd = 0;
      }
    }
  }

  return [newCargo, true, addedCargo];
}

// returns a table of [0 = resulting cargo, 1 = success, 2 = items removed]
function removeCargo(commodityName, count, CARGO) {

  CARGO = CARGO??cargo // sets the input cargo array to the ship's if none is given

  let cargoToRemove = count;
  let removedCargo = 0;
  let newCargo = JSON.parse(JSON.stringify(CARGO));

  let cargoFound = false;
  for (let i = 0; i < newCargo.length; i++) {
    if (newCargo[i][0] == commodityName) cargoFound = true;
  }

  // error handling
  if (commodityName == "EMPTY") {
    print('DONT TRY TO REMOVE "EMPTY" YOU IDIOT!');
    return [CARGO, false, 0];
  }
  if (!cargoFound) {
    return [CARGO, false, 0];
  }
  if (count < 0) {
    print("USE addCargo TO ADD CARGO, NOT removeCargo!");
    return [CARGO, false, 0];
  }

  for (let i = newCargo.length - 1; i >= 0; i--) {
    if (newCargo[i][0] == commodityName) {
      if (cargoToRemove >= newCargo[i][1]) {
        cargoToRemove -= newCargo[i][1];
        removedCargo += newCargo[i][1];
        newCargo[i][1] = 0;
      } else {
        newCargo[i][1] -= cargoToRemove;
        removedCargo += cargoToRemove;
        cargoToRemove = 0;
      }

      if (newCargo[i][1] == 0) {
        newCargo[i] = ["EMPTY"];
      }
    }
  }

  return [newCargo, true, removedCargo];
}

// returns the resulting cargo array
function clearStack(stackIndex, CARGO) {

  CARGO = CARGO??cargo // sets the input cargo array to the ship's if none is given

  let newCargo = CARGO;
  if (stackIndex >= CARGO.length) return CARGO;
  newCargo[stackIndex] = ["EMPTY"];
  return newCargo;
}

// returns how much of the entered item you have, or how many stacks of EMPTY you have
function getCargo(commodityName, CARGO) {

  CARGO = CARGO??cargo // sets the input cargo array to the ship's if none is given

  let itemCount = 0;
  for (let i = 0; i < CARGO.length; i++) {
    if (CARGO[i][0] == commodityName) {
      if (commodityName == "EMPTY") {
        itemCount++;
      } else {
        itemCount += CARGO[i][1];
      }
    }
  }
  return itemCount;
}

// returns an array of [*cargo size [0 = % full, 1 = commod color]]
function displayCargo(Cargo) {
  let cargoDisplay = [];
  for (let i = 0; i < Cargo.length; i++) {
    cargoDisplay[i] = [];
    if (Cargo[i][0] == "EMPTY") {
      cargoDisplay[i][0] = 0;
      cargoDisplay[i][1] = color(100);
    } else {
      let com = getCommodity(Cargo[i][0]);
      cargoDisplay[i][0] = (Cargo[i][1] * com[4]) / maxStack;
      cargoDisplay[i][1] = com[5];
    }
  }
  return cargoDisplay;
}

// gets the total price of a trade by getting the price for each single item to get the most precise price
// BS: true = buying, false = selling
// REQUIRES THE STATION COMMODITY DATA, NOT THE NAME
// oh come on it was broken because I forgot about PEMDAS
function tradePrice(BS, staComm, amount) {
  let cost = 0;
  let com;
  for (let c = 0; c < commod.length; c++) {
    if (commod[c][0] == staComm[0]) {
      com = commod[c];
    }
  }
  if (BS) {
    for (let i = 0; i < amount; i++) {
      let price;
      var demandMult = (staComm[2] - i) / staComm[1];
      if (demandMult > 1.25) demandMult = 1.25;
      if (demandMult < 0.75) demandMult = 0.75;
      price = com[1] * demandMult + staComm[3];
      cost += round(price, 2);
    }
  } else {
    for (let i = 0; i < amount; i++) {
      let price;
      var demandMult = (staComm[2] + i) / staComm[1];
      if (demandMult > 1.25) demandMult = 1.25;
      if (demandMult < 0.75) demandMult = 0.75;
      price = com[1] * demandMult + staComm[3];
      cost += round(price, 2);
    }
  }
  return cost;
}

var dis = 0;
var Bdis = 1000;
var cS = "null";
var cP = "null";
var cSt = "null";
var ast = false;
var dtCount = 0;
var Psta = "null";
var TS = 0;
var cScroll = 0;
var sComm = 0;
var sTab = "buy"
var Tmult = 1;
var buysell = 1;
var cart = 0;

let timers = [];

function newTimer(name) {
  timers[timers.length] = [];
  timers[timers.length - 1][0] = name;
  timers[timers.length - 1][1] = dtCount;
  timers[timers.length - 1][2] = false;
}

function getTimer(name) {
  for (let i = 0; i < timers.length; i++) {
    if (timers[i][0] == name) {
      return dtCount - timers[i][1];
    }
  }
}

function resetTimer(name) {
  for (let i = 0; i < timers.length; i++) {
    if (timers[i][0] == name) {
      timers[i][1] = dtCount;
    }
  }
}

function removeTimer(name) {
  for (let i = 0; i < timers.length; i++) {
    if (timers[i][0] == name) {
      for (let a = i; a < timers.length; a++) {
        timers[a] = timers[a + 1];
      }
      timers.length = timers.length - 1;
      break;
    }
  }
}

function setTimerPaused(name, paused) {
  for (let i = 0; i < timers.length; i++) {
    if (timers[i][0] == name) {
      timers[i][2] = paused;
    }
  }
}

newTimer("Jump Timer");
  
var pressed = false;
  
var jumping = false;
var jumpBegin = false;
var destination = "none"
// string "S-#[-S-# or -P-#]"
// the first S-# is the index of the star
// after the first S-# can be another - followed by S-# or P-#
// if the second part is S-# it indicates a station and a station index
// if the second part is P-# it indicates a celestial body (planet, asteroid belt, etc.) and an index
// EX: "S-32-S-1" would attempt to jump to the first station at star 32

let initInteg

function hyperjump(target){
  if(!jumping){
    jumping = true;
    jumpBegin = true;
    destination = target;
  }
}
  
function loadScene(target){
  // remove everything and reset the player
  let rot = playerShip.rotation
  let integ = playerShip.integrity
  docked = false
  
  allSprites.removeAll();
  
  playerShip = new Sprite(0,0,8,6);
  playerShip.mass = 0.7
  playerShip.rotationDrag = 5
  playerShip.drag = 5
  playerShip.color = color(10,10,15)
  playerShip.stroke = color(0,0,255)
  playerShip.strokeWeight = 3
  playerShip.maxIntegrity = 100;
  playerShip.integrity = integ;
  
  playerShip.x = 0
  playerShip.y = 0
  playerShip.rotation = rot
  playerShip.rotationSpeed = 0
  playerShip.speed = 0
  camera.x = playerShip.x
  camera.y = playerShip.y
  
  // get the star index
  let star = + target.split("-")[1]
  Pstar = star
  Pstation = "null";
  
  if(target.includes("-S-")){
    
    // extracts the station index from the string using dark magic
    let sta = + target.split("-")[3]
    Pstation = sta
    
    let Scol;
    switch (stations[Pstar][Pstation][0]){
        case "Mining":
          Scol = color(240, 160, 0);
          break;
        case "Refining":
          Scol = color(240, 200, 0);
          break;
        case "Technology":
          Scol = color(0, 50, 230);
          break;
        case "Organics":
          Scol = color(0, 255, 20);
          break;
        case "Manufacturing":
          Scol = color(120, 20, 0);
          break;
    }
    createStation(color(Scol))
  }
}
  
// auto resize
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  clearButtons()
  buttonsLoaded = false
}

// button and mouse input handling
function mouseReleased() {
  pressed = false;

  for (let i = 0; i < buttons.length; i++) {
    if (
      buttons[i][0] &&
      mouseX > buttons[i][4] &&
      mouseX < buttons[i][4] + buttons[i][6] &&
      mouseY > buttons[i][5] &&
      mouseY < buttons[i][5] + buttons[i][7] &&
      !pressed
    ) {
      buttons[i][13]();
      pressed = true;
    }
  }
}

var timersCreated = false;
  
var messages = []
var maxMessages = 10

function consoleMessage(string, seconds){
  if(messages.length >= maxMessages){
    messages.splice(0,1)
  }
  messages[messages.length] = [string, seconds * 1000]
}

function draw() {
  background(10, 10, 15);
  
  if(!paused){
    dtCount = dtCount + floor(deltaTime) / 1000;
    dtCount = dtCount - (dtCount % 0.001); // attempts to to remove floating point inaccuracies
    world.autoStep = true
  } else {
    world.autoStep = false
  }
  
  if(DTlog.push(floor(deltaTime) / 1000) >= 10){
    DTlog.splice(0,1)
  }
  
  // pausing control
  if(kb.pressed("escape") && screen == "NONE") {
    paused = true // only toggle pausing if the player is not in a menu or in the pause menu
    buttonsLoaded = false
  } else if (kb.pressed("escape")) { // if escape is pressed in a menu then close the menu instead of pausing
    screen = "NONE"
    paused = false
    clearButtons()
    buttonsLoaded = false
  }
  if(paused) screen = "PAUSE"

  // update modules
  for(let i = 0; i < modules.length; i++){
    modules[i]?.update()
  }
  
  // background
  stroke(255)
  strokeWeight(2)
  for (let i = 1; i <= m.length / 2; i++) {
      switch (cl[i]) {
        case "Red M-Class":
          stroke(255, 235, 235);
          break;

        case "Yellow M-Class":
          stroke(255, 255, 230);
          break;

        case "Blue M-Class":
          stroke(220, 225, 255);
          break;

        case "Red Giant":
          stroke(255, 210, 210);
          break;
      }
      point(5*(m[i * 2 - 2]-m[Pstar * 2 - 2]) + (windowWidth/2), 5*(m[i * 2 - 1]-m[Pstar * 2 - 1]) + (windowHeight/2));
    }
  noStroke()
  fill(10,10,15)
  rect(windowWidth/2 - 3, windowHeight/2 - 3, windowWidth/2 + 3, windowHeight/2 + 3)
  
  // smooth-ish camera follow
  camera.x = playerShip.x - (playerShip.vel.x * 2)
  camera.y = playerShip.y - (playerShip.vel.y * 2)
  
  playerShip.bearing = playerShip.rotation - 90;
  if(kb.pressing("up")) playerShip.applyForce(speed)
  if(kb.pressing("down")) playerShip.applyForce(-speed/2)
  if(kb.pressing("right")) playerShip.applyTorque(turn)
  if(kb.pressing("left")) playerShip.applyTorque(-turn)
  
  if(kb.pressing("up")&&kb.pressing("left")&&kb.pressing("right")){
    playerShip.drag = 0.2
    playerShip.rotationDrag = 0.2
  } else {
    playerShip.drag = 0.5
    playerShip.rotationDrag = 0.5
  }
  
  playerShip.draw = () => {
    
    fill(200,100,0)
    noStroke()
    
    if(kb.pressing("up") && !docked){
      triangle(2,3,-2,3,0,sin(dtCount*360*8)*1+3.8)
    }
    if(kb.pressing("left") && !docked){
      triangle(2.5,2.8,4,0.5,cos(40)*(sin(dtCount*360*8)*2)+3.3,sin(40)*(sin(dtCount*360*8)*2)+1.7)
    }
    if(kb.pressing("right") && !docked){
      triangle(-2.5,2.8,-4,0.5,cos(140)*(sin(dtCount*360*8)*2)-3.3,sin(140)*(sin(dtCount*360*8)*2)+1.7)
    }
    
    stroke(0,50,240)
    strokeWeight(0.3)
    fill(10,10,15)
    
    triangle(0,0.5,2,3,-2,3)
    triangle(-0.5,0.5,-2.5,2.8,-4,0.5)
    triangle(0.5,0.5,2.5,2.8,4,0.5)
    
    noStroke()
    triangle(0,0,2,-3,-2,-3)
    triangle(0,0,4,0,2,-3)
    triangle(0,0,-4,0,-2,-3)
    
    stroke(0,50,240)
    line(-4,0,4,0)
    line(4,0,2,-3)
    line(2,-3,-2,-3)
    line(-4,0,-2,-3)
    
  }
  
  if(kb.pressed("j") && destination != "none" && !paused && screen == "NONE"){
    hyperjump(destination)
  }
  
  // code for hyper-jump sequence
  if(jumping){
    
    if(jumpBegin){
      
      resetTimer("Jump Timer");
      
      // prevents the player from moving
      speed = 0;
      turn = 0;
      docked = true;
      playerShip.rotationSpeed = 0
      
      initInteg = playerShip.integrity
      
      consoleMessage("initiating hyper-jump to " + destination, 10)
      
      jumpBegin = false
      
      
      
    }
    
    let Jtimer = getTimer("Jump Timer")
    
    let ring1rad = 75;
    let ring1speed = 270;
    let ring1sides = 12
    
    let ring1TRad;
    
    if(Jtimer <= 1){
      ring1TRad = ring1rad * sin(Jtimer*90);
    } else {
      ring1TRad = ring1rad;
    }
    
    let ring1rot = Jtimer * (Jtimer/2) * ring1speed;
    ring1TRad += Jtimer * 5
    
    for(let i = 0; i < ring1sides; i++){
      noStroke()
      fill(10,10,15)
      triangle(
        windowWidth/2, windowHeight/2,
        (windowWidth/2) + ring1TRad * cos(ring1rot + (360/ring1sides)*i),
           (windowHeight/2) + ring1TRad * sin(ring1rot + (360/ring1sides)*i),
          (windowWidth/2) + ring1TRad * cos(ring1rot + (360/ring1sides)*(i+1)),
           (windowHeight/2) + ring1TRad * sin(ring1rot + (360/ring1sides)*(i+1))
      )
      noFill()
      strokeWeight(2)
      stroke(0,0,255)
      line( (windowWidth/2) + ring1TRad * cos(ring1rot + (360/ring1sides)*i),
           (windowHeight/2) + ring1TRad * sin(ring1rot + (360/ring1sides)*i),
          (windowWidth/2) + ring1TRad * cos(ring1rot + (360/ring1sides)*(i+1)),
           (windowHeight/2) + ring1TRad * sin(ring1rot + (360/ring1sides)*(i+1)))
    }
    
    
    let ring2rad = 40;
    let ring2speed = -180;
    let ring2sides = 9
    
    let ring2TRad = 0;
    
    if(Jtimer <= 2 && Jtimer > 1){
      ring2TRad = ring2rad * sin((Jtimer - 1)*90);
    } else if(Jtimer > 2) {
      ring2TRad = ring2rad;
    }
    
    let ring2rot = Jtimer * (ring2speed * ((Jtimer**2)/5) );
    ring2TRad += Jtimer**3
    
    for(let i = 0; i < ring2sides; i++){
      noStroke()
      fill(10,10,15)
      triangle(
        windowWidth/2, windowHeight/2,
        (windowWidth/2) + ring2TRad * cos(ring2rot + (360/ring2sides)*i),
           (windowHeight/2) + ring2TRad * sin(ring2rot + (360/ring2sides)*i),
          (windowWidth/2) + ring2TRad * cos(ring2rot + (360/ring2sides)*(i+1)),
           (windowHeight/2) + ring2TRad * sin(ring2rot + (360/ring2sides)*(i+1))
      )
      noFill()
      strokeWeight(2)
      stroke(0,0,255)
      line( (windowWidth/2) + ring2TRad * cos(ring2rot + (360/ring2sides)*i),
           (windowHeight/2) + ring2TRad * sin(ring2rot + (360/ring2sides)*i),
          (windowWidth/2) + ring2TRad * cos(ring2rot + (360/ring2sides)*(i+1)),
           (windowHeight/2) + ring2TRad * sin(ring2rot + (360/ring2sides)*(i+1)))
    }
    
    strokeWeight(1)
    
    // stop the hyper-jump sequence if hit
    if(playerShip.integrity < initInteg) { 
      jumping = false
      consoleMessage("hyper-jump interrupted!", 5)
    }
    
    if(Jtimer >= 3){
      speed = 0.5
      turn = 0.0005
      loadScene(destination)
      destination = "none"
      consoleMessage("hyper-jump successful", 8)
      jumping = false
    }
    
  }
  
  
  // SPRITES AND PHYSICS GO ABOVE
  
  camera.on()
  allSprites.draw()
  camera.off()
  
  // UI AND MENUS GO BELOW
  
  // console
  
  let consoleText = ""
  for(let i = 0; i < messages.length; i++){
    
    consoleText += messages[i][0] + "\n"
    
    messages[i][1] -= deltaTime
    if(messages[i][1] <= 0) messages.splice(i,1)
    
  }
  textAlign(LEFT, TOP)
  textSize(13)
  noStroke()
  fill(255,255,255,150)
  text(consoleText, 10, 10)
  
  // hull integrity

  if(playerShip.integrity / playerShip.maxIntegrity > 0.5){
    stroke(255)
  } else if(playerShip.integrity / playerShip.maxIntegrity <= 0.5 && playerShip.integrity / playerShip.maxIntegrity > 0.2){
    stroke(255,255,0)
  } else if(playerShip.integrity / playerShip.maxIntegrity <= 0.2){
    stroke(255,0,0)
  }
  strokeWeight(2)
  fill(10, 10, 15)

  rect(50, windowHeight - 80, 240, 30)
  line(50 + ( 240 * (playerShip.integrity / playerShip.maxIntegrity) ), windowHeight - 80, 50 + ( 240 * (playerShip.integrity / playerShip.maxIntegrity) ), windowHeight - 50)

  noStroke()
  if(playerShip.integrity / playerShip.maxIntegrity > 0.5){
    fill(255)
  } else if(playerShip.integrity / playerShip.maxIntegrity <= 0.5 && playerShip.integrity / playerShip.maxIntegrity > 0.2){
    fill(255,255,0)
  } else if(playerShip.integrity / playerShip.maxIntegrity <= 0.2){
    fill(255,0,0)
  }
  textSize(20)
  textAlign(LEFT,CENTER)
  text( playerShip.integrity + "/" + playerShip.maxIntegrity, 55, windowHeight - 80, 240, 30)
  
  textSize(15);
  text("hull", 50, windowHeight - 95);
  
  // fuel
  
  stroke(255)
  strokeWeight(2)
  fill(10, 10, 15)

  rect( windowWidth - 290, windowHeight - 80, 240, 30)
  line(windowWidth - 290 + ( 240 * (fuel / maxFuel) ), windowHeight - 80, windowWidth - 290 + ( 240 * (fuel / maxFuel) ), windowHeight - 50)

  noStroke()
  fill(255)
  textSize(20)
  textAlign(LEFT,CENTER)
  text( fuel + "/" + maxFuel, windowWidth - 285, windowHeight - 80, 240, 30)
  
  textAlign(RIGHT,CENTER)
  textSize(15);
  text("fuel", windowWidth - 290, windowHeight - 105, 240, 15);
  
  
  if(destination != "none" && !jumping){
    textAlign(CENTER,CENTER)
      textSize(20)
      fill(color(255,255,255,100))
      noStroke()
      text("press j to hyperjump",windowWidth/2,windowHeight/2 + 120)
  }
  
  // arrow pointing to station
  if(Pstation != "null"){
    
    if(station.removed){
      
      textAlign(CENTER,CENTER)
      textSize(20)
      fill(color(255,0,0,255))
      noStroke()
      text("docking aborted, re-jump to re-dock",windowWidth/2,windowHeight/2 + 100)
      
    } else {

      x = playerShip.x - station.x
      y = playerShip.y - station.y

      angle = atan(y/x)
      if(x > 0) angle = angle + 180

      noFill()
      stroke(200)
      strokeWeight(1.5)
      triangle(windowWidth/2 + cos(angle+5)*50,windowHeight/2 + sin(angle+5)*50,windowWidth/2 + cos(angle-5)*50,windowHeight/2 + sin(angle-5)*50,windowWidth/2 + cos(angle)*75,windowHeight/2 + sin(angle)*75)
      
      textAlign(CENTER,CENTER)
      textSize(15)
      fill(color(255,255,255,255))
      noStroke()
      text((round((sqrt(x*x+y*y)-station.diameter/2)/1))+" m", windowWidth/2 + cos(angle)*110,windowHeight/2 + sin(angle)*110)

      updateStation();

      if(docked){
        /*textAlign(CENTER,CENTER)
        textSize(20)
        fill(color(255,255,255,100))
        noStroke()
        text("press e to undock",350,350)*/
      } else if(canDock){
        textAlign(CENTER,CENTER)
        textSize(20)
        fill(color(255,255,255,100))
        noStroke()
        text("press e to dock",windowWidth/2,windowHeight/2 + 100)
      }
      canDock = false;
    }
  }
  
  if(kb.pressed("m") && (screen != "STARS" && screen != "SYSTEM" && screen != "STATION") && !paused){
    screen = "SYSTEM"
    buttonsLoaded = false;
  } else if(kb.pressed("m") && (screen == "STARS" || screen == "SYSTEM")){
    screen = "NONE"
    clearButtons()
    buttonsLoaded = false;
  }
  if(kb.pressed("c") && (screen == "NONE" || screen == "SYSTEM" || screen == "STARS") && !paused){
    screen = "SHIP"
    buttonsLoaded = false;
    clearButtons()
  } else if (kb.pressed("c") && screen == "SHIP"){
    screen = "NONE"
    clearButtons()
    buttonsLoaded = false;
  }
  
  textSize(14);
  textAlign(LEFT, TOP);
  cursor(ARROW);

  // pause timers
  for (let i = 0; i < timers.length; i++) {
    if (timers[i][2]) {
      timers[i][1] =
        timers[i][1] + floor(deltaTime) / 1000 - (timers[i][1] % 0.001);
    }
  }

  // create main timers once
  if (!timersCreated) {
    newTimer("Restock");

    timersCreated = true;
  }

  // add items and process items every 20 seconds
  if (getTimer("Restock") >= 20) {
    for (let ss = 0; ss < stations.length; ss++) {
      for (let s = 0; s < stations[ss].length; s++) {
        switch (stations[ss][s][0]) {
          case "Mining":
            let stock = [];
            // table of commidities that can be restocked

            for (let c = 0; c < commod.length; c++) {
              for (let e = 0; e < commod[c][3].length; e++) {
                if (commod[c][3][e] == "Mining")
                  stock[stock.length] = commod[c][0];
              }
            }
            // gets the possible commodities to restock

            let toRestock = 5;
            for (let i = 0; i < toRestock; i++) {
              let toAdd = random(stock);
              for (let it = 0; it < stations[ss][s][4].length; it++) {
                if (
                  stations[ss][s][4][it][0] == toAdd &&
                  stations[ss][s][4][it][2] < stations[ss][s][4][it][1]
                )
                  stations[ss][s][4][it][2]++;
              }
            }
            // restocks toRestock possible commodities to the station

            break;

          case "Refining":
            // get the commodities that can be smelted
            let smeltable = [];
            for (let i = 0; i < smeltables.length; i++) {
              if(findCommodity(ss, s, smeltables[i][1])) smeltable[smeltable.length] = smeltables[i][1];
            }

            // smelt [NUMBER] smeltable commodites and exchange them for their smelted form
            let toSmelted = 5;
            for (let i = 0; i < toSmelted; i++) {
              let toSmelt = round(random(0, smeltable.length - 1));
              if (
                findCommodity(ss, s, smeltable[toSmelt])[2] >=
                  smeltables[toSmelt][0] &&
                findCommodity(ss, s, smeltables[toSmelt][3])[1] -
                  findCommodity(ss, s, smeltables[toSmelt][3])[2] >=
                  smeltables[toSmelt][2]
              ) {
                // checks if there is enough to smelt and if there is enough room for the output
                findCommodity(ss, s, smeltable[toSmelt])[2] -=
                  smeltables[toSmelt][0];
                findCommodity(ss, s, smeltables[toSmelt][3])[2] +=
                  smeltables[toSmelt][2];
              }
            }

            break;
        }
      }
    }

    //DEBUG, DELETE ONCE FINISHED
    print(stations);

    resetTimer("Restock");
  }
  
  if(FPScounter){
    textSize(12)
    noStroke()
    fill(255)
    let FPS = 0;
    for(let i = 0; i < DTlog.length; i++){
      FPS += DTlog[i]
    }
    FPS /= DTlog.length
    FPS = 1/FPS
    FPS = round(FPS, 1)
    text("FPS: "+FPS,10,10)
  }

  textSize(13.5);
  textAlign(LEFT, TOP);
  
  
  // menus
  // these get very big so I just put them in seperate files

  if (screen == "STARS") {
    
    // code is in scripts/starScreen.js
    starScreen()
    
  }

  if (screen == "SYSTEM") {
    
    // code is in scripts/systemScreen.js
    systemScreen()
    
  }

  if (screen == "STATION") {
    
    // code is in scripts/stationScreen.js
    stationScreen()
    
  }
  
  if (screen == "SHIP"){

    // code is in scripts/shipScreen.js
    shipScreen()

  }

  if (screen.split(" ")[0] == "MODULE"){
    if(+screen.split(" ")[1] > modules.length){ 
      screen = "SHIP"
      shipScreen()
    }else{
      if(modules[+screen.split(" ")[1]]?.screen??false){
        modules[+screen.split(" ")[1]].screen()
      } else {
        screen = "SHIP"
        shipScreen()
      }
    }
  }
  
  if(screen == "PAUSE"){
    
    let xOffset = round((windowWidth/2)-100)
    let yOffset = round((windowHeight/2)-150)
    
    stroke(themeSecondary)
    strokeWeight(2)
    fill(10,10,25)
    rect(xOffset,yOffset,200,300)
    
    if (!buttonsLoaded) {
      clearButtons();
      // newButton(name,displayText,textsize,X,Y,W,H,Col1,Col2,ColP1,ColP2,bWidth,func,alx,aly)
      newButton("Resume Button","resume",20,xOffset + 5, yOffset + 5, 190, 30, themeSecondary, color(10,10,15), themeSecondary, color(10,10,15), 2, function(){
        paused = false;
        screen = "NONE"
        buttonsLoaded = false
        clearButtons()
      })
      
      setButtonEnabled("Resume Button", true)
      
      newButton("FPS Counter Button","FPS counter: " + (FPScounter ? "on" : "off"),20,xOffset + 5, yOffset + 40, 190, 30, themeSecondary, color(10,10,15), themeSecondary, color(10,10,15), 2, function(){
        FPScounter = !FPScounter
        setButtonText("FPS Counter Button", "FPS counter: " + (FPScounter ? "on" : "off"))
      })
      
      setButtonEnabled("FPS Counter Button", true)

      buttonsLoaded = true;
    }
    
    textSize(16)
    noStroke()
    fill(themeSecondary)
    text("CONTROLS\nMove: WASD / arrow keys\nOpen/Close Map: M\nHyper-Jump: J\nDock: E\nExit Menu: escape\nPause: escape\nShip Menu: C\n\nsettings and saving\ncoming soon(ish)",xOffset + 10, yOffset + 80)
  }
  
  
  
  // draw buttons
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i][0] && !buttons[i][17]) {
      let Hover =
        mouseX > buttons[i][4] &&
        mouseX < buttons[i][4] + buttons[i][6] &&
        mouseY > buttons[i][5] &&
        mouseY < buttons[i][5] + buttons[i][7];
      strokeWeight(buttons[i][12]);
      textAlign(buttons[i][14], buttons[i][15]);
      if (!Hover) {
        stroke(buttons[i][8]);
        fill(buttons[i][9]);
        rect(
          buttons[i][4] + 0.5,
          buttons[i][5] + 0.5,
          buttons[i][6],
          buttons[i][7]
        );
        noStroke();
        fill(buttons[i][8]);
        textSize(buttons[i][3]);
        text(
          buttons[i][2],
          buttons[i][4] + 0.5 + buttons[i][16],
          buttons[i][5] + 0.5 + buttons[i][16],
          buttons[i][6] - buttons[i][16] * 2,
          buttons[i][7] - buttons[i][16] * 2
        );
      } else if (Hover) {
        stroke(buttons[i][10]);
        fill(buttons[i][10]);
        rect(
          buttons[i][4] + 0.5,
          buttons[i][5] + 0.5,
          buttons[i][6],
          buttons[i][7]
        );
        noStroke();
        fill(buttons[i][11]);
        textSize(buttons[i][3]);
        text(
          buttons[i][2],
          buttons[i][4] + 0.5 + buttons[i][16],
          buttons[i][5] + 0.5 + buttons[i][16],
          buttons[i][6] - buttons[i][16] * 2,
          buttons[i][7] - buttons[i][16] * 2
        );
        cursor(HAND);
      }
    }
    buttons[i][17] = false
  }
  
}
